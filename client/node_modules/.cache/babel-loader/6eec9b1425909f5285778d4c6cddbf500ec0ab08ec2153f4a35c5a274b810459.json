{"ast":null,"code":"import { parser, props } from '@nextjournal/lezer-clojure';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { LRLanguage, indentNodeProp, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\n/**\nA language provider based on the [Lezer Clojure](https://github.com/nextjournal/lezer-clojure), extended with\nhighlighting and indentation information.\n*/\nconst {\n  coll\n} = props;\n// debug\n// const nodeText = (state, node: SyntaxNode) => { return state.doc.sliceString(node.from, node.to) }\nconst clojureLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/styleTags({\n      NS: tags.keyword,\n      DefLike: tags.keyword,\n      \"Operator/Symbol\": tags.keyword,\n      \"VarName/Symbol\": /*@__PURE__*/tags.definition(tags.variableName),\n      // Symbol: tags.keyword,\n      // \"'\": tags.keyword, // quote\n      Boolean: tags.atom,\n      \"DocString/...\": tags.emphasis,\n      \"Discard!\": tags.comment,\n      Number: tags.number,\n      StringContent: tags.string,\n      \"\\\"\\\\\\\"\\\"\": tags.string,\n      Keyword: tags.atom,\n      Nil: tags.null,\n      LineComment: tags.lineComment,\n      RegExp: tags.regexp\n    }), /*@__PURE__*/indentNodeProp.add(nodeType => {\n      return context => {\n        let {\n          pos,\n          unit,\n          node,\n          state,\n          baseIndent,\n          textAfter\n        } = context;\n        if (nodeType.prop(coll)) {\n          // same behaviour as in clojure-mode: args after operator are always 2-units indented\n          let parentBase = context.column(node.firstChild.to); // column at the right of parent opening-(\n          if (\"List\" == nodeType.name && [\"NS\", \"DefLike\", \"Operator\"].includes(node.firstChild.nextSibling.type.name)) {\n            return parentBase + 1;\n          } else {\n            return parentBase;\n          }\n        } else {\n          return 0;\n        }\n      };\n    }), /*@__PURE__*/foldNodeProp.add({\n      [\"Vector Map List\"]: foldInside\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      line: \";;\"\n    }\n  }\n});\nfunction clojure() {\n  return new LanguageSupport(clojureLanguage);\n}\nexport { clojure, clojureLanguage };","map":{"version":3,"names":["parser","props","styleTags","tags","LRLanguage","indentNodeProp","foldNodeProp","foldInside","LanguageSupport","coll","clojureLanguage","define","configure","NS","keyword","DefLike","definition","variableName","Boolean","atom","emphasis","comment","Number","number","StringContent","string","Keyword","Nil","null","LineComment","lineComment","RegExp","regexp","add","nodeType","context","pos","unit","node","state","baseIndent","textAfter","prop","parentBase","column","firstChild","to","name","includes","nextSibling","type","languageData","commentTokens","line","clojure"],"sources":["/Users/EL-CAPITAN-2016/Development/mentor/client/node_modules/@nextjournal/lang-clojure/dist/index.js"],"sourcesContent":["import { parser, props } from '@nextjournal/lezer-clojure';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { LRLanguage, indentNodeProp, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\n/**\nA language provider based on the [Lezer Clojure](https://github.com/nextjournal/lezer-clojure), extended with\nhighlighting and indentation information.\n*/\nconst { coll } = props;\n// debug\n// const nodeText = (state, node: SyntaxNode) => { return state.doc.sliceString(node.from, node.to) }\nconst clojureLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [/*@__PURE__*/styleTags({ NS: tags.keyword,\n                DefLike: tags.keyword,\n                \"Operator/Symbol\": tags.keyword,\n                \"VarName/Symbol\": /*@__PURE__*/tags.definition(tags.variableName),\n                // Symbol: tags.keyword,\n                // \"'\": tags.keyword, // quote\n                Boolean: tags.atom,\n                \"DocString/...\": tags.emphasis,\n                \"Discard!\": tags.comment,\n                Number: tags.number,\n                StringContent: tags.string,\n                \"\\\"\\\\\\\"\\\"\": tags.string,\n                Keyword: tags.atom,\n                Nil: tags.null,\n                LineComment: tags.lineComment,\n                RegExp: tags.regexp }),\n            /*@__PURE__*/indentNodeProp.add((nodeType) => {\n                return (context) => {\n                    let { pos, unit, node, state, baseIndent, textAfter } = context;\n                    if (nodeType.prop(coll)) {\n                        // same behaviour as in clojure-mode: args after operator are always 2-units indented\n                        let parentBase = context.column(node.firstChild.to); // column at the right of parent opening-(\n                        if (\"List\" == nodeType.name && [\"NS\", \"DefLike\", \"Operator\"].includes(node.firstChild.nextSibling.type.name)) {\n                            return parentBase + 1;\n                        }\n                        else {\n                            return parentBase;\n                        }\n                    }\n                    else {\n                        return 0;\n                    }\n                };\n            }),\n            /*@__PURE__*/foldNodeProp.add({ [\"Vector Map List\"]: foldInside })]\n    }),\n    languageData: { commentTokens: { line: \";;\" } }\n});\nfunction clojure() {\n    return new LanguageSupport(clojureLanguage);\n}\n\nexport { clojure, clojureLanguage };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,KAAK,QAAQ,4BAA4B;AAC1D,SAASC,SAAS,EAAEC,IAAI,QAAQ,kBAAkB;AAClD,SAASC,UAAU,EAAEC,cAAc,EAAEC,YAAY,EAAEC,UAAU,EAAEC,eAAe,QAAQ,sBAAsB;;AAE5G;AACA;AACA;AACA;AACA,MAAM;EAAEC;AAAK,CAAC,GAAGR,KAAK;AACtB;AACA;AACA,MAAMS,eAAe,GAAG,aAAaN,UAAU,CAACO,MAAM,CAAC;EACnDX,MAAM,EAAE,aAAaA,MAAM,CAACY,SAAS,CAAC;IAClCX,KAAK,EAAE,CAAC,aAAaC,SAAS,CAAC;MAAEW,EAAE,EAAEV,IAAI,CAACW,OAAO;MACzCC,OAAO,EAAEZ,IAAI,CAACW,OAAO;MACrB,iBAAiB,EAAEX,IAAI,CAACW,OAAO;MAC/B,gBAAgB,EAAE,aAAaX,IAAI,CAACa,UAAU,CAACb,IAAI,CAACc,YAAY,CAAC;MACjE;MACA;MACAC,OAAO,EAAEf,IAAI,CAACgB,IAAI;MAClB,eAAe,EAAEhB,IAAI,CAACiB,QAAQ;MAC9B,UAAU,EAAEjB,IAAI,CAACkB,OAAO;MACxBC,MAAM,EAAEnB,IAAI,CAACoB,MAAM;MACnBC,aAAa,EAAErB,IAAI,CAACsB,MAAM;MAC1B,UAAU,EAAEtB,IAAI,CAACsB,MAAM;MACvBC,OAAO,EAAEvB,IAAI,CAACgB,IAAI;MAClBQ,GAAG,EAAExB,IAAI,CAACyB,IAAI;MACdC,WAAW,EAAE1B,IAAI,CAAC2B,WAAW;MAC7BC,MAAM,EAAE5B,IAAI,CAAC6B;IAAO,CAAC,CAAC,EAC1B,aAAa3B,cAAc,CAAC4B,GAAG,CAAEC,QAAQ,IAAK;MAC1C,OAAQC,OAAO,IAAK;QAChB,IAAI;UAAEC,GAAG;UAAEC,IAAI;UAAEC,IAAI;UAAEC,KAAK;UAAEC,UAAU;UAAEC;QAAU,CAAC,GAAGN,OAAO;QAC/D,IAAID,QAAQ,CAACQ,IAAI,CAACjC,IAAI,CAAC,EAAE;UACrB;UACA,IAAIkC,UAAU,GAAGR,OAAO,CAACS,MAAM,CAACN,IAAI,CAACO,UAAU,CAACC,EAAE,CAAC,CAAC,CAAC;UACrD,IAAI,MAAM,IAAIZ,QAAQ,CAACa,IAAI,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,UAAU,CAAC,CAACC,QAAQ,CAACV,IAAI,CAACO,UAAU,CAACI,WAAW,CAACC,IAAI,CAACH,IAAI,CAAC,EAAE;YAC1G,OAAOJ,UAAU,GAAG,CAAC;UACzB,CAAC,MACI;YACD,OAAOA,UAAU;UACrB;QACJ,CAAC,MACI;UACD,OAAO,CAAC;QACZ;MACJ,CAAC;IACL,CAAC,CAAC,EACF,aAAarC,YAAY,CAAC2B,GAAG,CAAC;MAAE,CAAC,iBAAiB,GAAG1B;IAAW,CAAC,CAAC;EAC1E,CAAC,CAAC;EACF4C,YAAY,EAAE;IAAEC,aAAa,EAAE;MAAEC,IAAI,EAAE;IAAK;EAAE;AAClD,CAAC,CAAC;AACF,SAASC,OAAOA,CAAA,EAAG;EACf,OAAO,IAAI9C,eAAe,CAACE,eAAe,CAAC;AAC/C;AAEA,SAAS4C,OAAO,EAAE5C,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}
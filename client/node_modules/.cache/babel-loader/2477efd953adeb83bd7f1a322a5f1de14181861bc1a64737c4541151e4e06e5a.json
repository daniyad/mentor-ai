{"ast":null,"code":"var ERRORCLASS = \"error\";\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\", \"isnt\", \"in\", \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\", \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\", \"do\", \"in\", \"of\", \"new\", \"return\", \"then\", \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\nindentKeywords = wordRegexp(indentKeywords);\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n  if (stream.eatSpace()) {\n    return null;\n  }\n  var ch = stream.peek();\n\n  // Handle docco title comment (single line)\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle multi line comments\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Single line comment\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle number literals\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false;\n    // Floats\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\") {\n        stream.backUp(1);\n      }\n      return \"number\";\n    }\n    // Integers\n    var intLiteral = false;\n    // Hex\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    }\n    // Decimal\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    }\n    // Zero by itself with no other piece of number.\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n    if (intLiteral) {\n      return \"number\";\n    }\n  }\n\n  // Handle strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  }\n  // Handle regex literals\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) {\n      // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  }\n\n  // Handle operators and delimiters\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return ERRORCLASS;\n}\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n    return outclass;\n  };\n}\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    stream.eatWhile(\"#\");\n  }\n  return \"comment\";\n}\nfunction indent(stream, state) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"coffee\";\n  var offset = 0,\n    align = false,\n    alignOffset = null;\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n    var matched = false;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return true;\n    }\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current();\n\n  // Handle scope changes.\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n  if ((current === \"->\" || current === \"=>\") && stream.eol() || style === \"indent\") {\n    indent(stream, state);\n  }\n  var delimiter_index = \"[({\".indexOf(current);\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n  }\n  if (indentKeywords.exec(current)) {\n    indent(stream, state);\n  }\n  if (current == \"then\") {\n    dedent(stream, state);\n  }\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n  delimiter_index = \"])}\".indexOf(current);\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev) state.scope = state.scope.prev;\n    if (state.scope.type == current) state.scope = state.scope.prev;\n  }\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev) state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\nexport const coffeeScript = {\n  name: \"coffeescript\",\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      scope: {\n        offset: 0,\n        type: \"coffee\",\n        prev: null,\n        align: false\n      },\n      prop: false,\n      dedent: 0\n    };\n  },\n  token: function (stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n    var style = tokenLexer(stream, state);\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\";\n    }\n    return style;\n  },\n  indent: function (state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align) return scope.alignOffset - (closes ? 1 : 0);else return (closes ? scope.prev : scope).offset;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["ERRORCLASS","wordRegexp","words","RegExp","join","operators","delimiters","identifiers","atProp","wordOperators","indentKeywords","commonKeywords","keywords","concat","stringPrefixes","regexPrefixes","commonConstants","constants","tokenBase","stream","state","sol","scope","align","scopeOffset","offset","eatSpace","lineOffset","indentation","type","dedent","ch","peek","match","skipToEnd","tokenize","longComment","floatLiteral","backUp","intLiteral","tokenFactory","current","prop","next","delimiter","singleline","outclass","eol","eatWhile","eat","indent","arguments","length","undefined","alignOffset","prev","indentUnit","column","_indent","matched","tokenLexer","style","delimiter_index","indexOf","slice","exec","coffeeScript","name","startState","token","fillAlign","text","closer","charAt","closes","languageData","commentTokens","line"],"sources":["/Users/EL-CAPITAN-2016/Development/mentor/client/node_modules/@codemirror/legacy-modes/mode/coffeescript.js"],"sourcesContent":["var ERRORCLASS = \"error\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                \"is\", \"isnt\", \"in\",\n                                \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                      \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                      \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                      \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\nindentKeywords = wordRegexp(indentKeywords);\n\n\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle docco title comment (single line)\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle multi line comments\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Single line comment\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle number literals\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false;\n    // Floats\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\"){\n        stream.backUp(1);\n      }\n      return \"number\";\n    }\n    // Integers\n    var intLiteral = false;\n    // Hex\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    }\n    // Decimal\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    }\n    // Zero by itself with no other piece of number.\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n    if (intLiteral) {\n      return \"number\";\n    }\n  }\n\n  // Handle strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  }\n  // Handle regex literals\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  }\n\n\n\n  // Handle operators and delimiters\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return ERRORCLASS;\n}\n\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n    return outclass;\n  };\n}\n\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    stream.eatWhile(\"#\");\n  }\n  return \"comment\";\n}\n\nfunction indent(stream, state, type = \"coffee\") {\n  var offset = 0, align = false, alignOffset = null;\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\n\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n    var matched = false;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return true;\n    }\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\n\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current();\n\n  // Handle scope changes.\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n  if (((current === \"->\" || current === \"=>\") && stream.eol())\n      || style === \"indent\") {\n    indent(stream, state);\n  }\n  var delimiter_index = \"[({\".indexOf(current);\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n  }\n  if (indentKeywords.exec(current)){\n    indent(stream, state);\n  }\n  if (current == \"then\"){\n    dedent(stream, state);\n  }\n\n\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n  delimiter_index = \"])}\".indexOf(current);\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    if (state.scope.type == current)\n      state.scope = state.scope.prev;\n  }\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\n\nexport const coffeeScript = {\n  name: \"coffeescript\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scope: {offset: 0, type:\"coffee\", prev: null, align: false},\n      prop: false,\n      dedent: 0\n    };\n  },\n\n  token: function(stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n\n    var style = tokenLexer(stream, state);\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\"\n    }\n\n    return style;\n  },\n\n  indent: function(state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align)\n      return scope.alignOffset - (closes ? 1 : 0);\n    else\n      return (closes ? scope.prev : scope).offset;\n  },\n\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
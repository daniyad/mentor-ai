{"ast":null,"code":"export function simpleMode(states) {\n  ensureState(states, \"start\");\n  var states_ = {},\n    meta = states.languageData || {},\n    hasIndentation = false;\n  for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n    var list = states_[state] = [],\n      orig = states[state];\n    for (var i = 0; i < orig.length; i++) {\n      var data = orig[i];\n      list.push(new Rule(data, states));\n      if (data.indent || data.dedent) hasIndentation = true;\n    }\n  }\n  return {\n    name: meta.name,\n    startState: function () {\n      return {\n        state: \"start\",\n        pending: null,\n        indent: hasIndentation ? [] : null\n      };\n    },\n    copyState: function (state) {\n      var s = {\n        state: state.state,\n        pending: state.pending,\n        indent: state.indent && state.indent.slice(0)\n      };\n      if (state.stack) s.stack = state.stack.slice(0);\n      return s;\n    },\n    token: tokenFunction(states_),\n    indent: indentFunction(states_, meta),\n    languageData: meta\n  };\n}\n;\nfunction ensureState(states, name) {\n  if (!states.hasOwnProperty(name)) throw new Error(\"Undefined state \" + name + \" in simple mode\");\n}\nfunction toRegex(val, caret) {\n  if (!val) return /(?:)/;\n  var flags = \"\";\n  if (val instanceof RegExp) {\n    if (val.ignoreCase) flags = \"i\";\n    val = val.source;\n  } else {\n    val = String(val);\n  }\n  return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n}\nfunction asToken(val) {\n  if (!val) return null;\n  if (val.apply) return val;\n  if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n  var result = [];\n  for (var i = 0; i < val.length; i++) result.push(val[i] && val[i].replace(/\\./g, \" \"));\n  return result;\n}\nfunction Rule(data, states) {\n  if (data.next || data.push) ensureState(states, data.next || data.push);\n  this.regex = toRegex(data.regex);\n  this.token = asToken(data.token);\n  this.data = data;\n}\nfunction tokenFunction(states) {\n  return function (stream, state) {\n    if (state.pending) {\n      var pend = state.pending.shift();\n      if (state.pending.length == 0) state.pending = null;\n      stream.pos += pend.text.length;\n      return pend.token;\n    }\n    var curState = states[state.state];\n    for (var i = 0; i < curState.length; i++) {\n      var rule = curState[i];\n      var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n      if (matches) {\n        if (rule.data.next) {\n          state.state = rule.data.next;\n        } else if (rule.data.push) {\n          (state.stack || (state.stack = [])).push(state.state);\n          state.state = rule.data.push;\n        } else if (rule.data.pop && state.stack && state.stack.length) {\n          state.state = state.stack.pop();\n        }\n        if (rule.data.indent) state.indent.push(stream.indentation() + stream.indentUnit);\n        if (rule.data.dedent) state.indent.pop();\n        var token = rule.token;\n        if (token && token.apply) token = token(matches);\n        if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n          state.pending = [];\n          for (var j = 2; j < matches.length; j++) if (matches[j]) state.pending.push({\n            text: matches[j],\n            token: rule.token[j - 1]\n          });\n          stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n          return token[0];\n        } else if (token && token.join) {\n          return token[0];\n        } else {\n          return token;\n        }\n      }\n    }\n    stream.next();\n    return null;\n  };\n}\nfunction indentFunction(states, meta) {\n  return function (state, textAfter) {\n    if (state.indent == null || meta.dontIndentStates && meta.doneIndentState.indexOf(state.state) > -1) return null;\n    var pos = state.indent.length - 1,\n      rules = states[state.state];\n    scan: for (;;) {\n      for (var i = 0; i < rules.length; i++) {\n        var rule = rules[i];\n        if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n          var m = rule.regex.exec(textAfter);\n          if (m && m[0]) {\n            pos--;\n            if (rule.next || rule.push) rules = states[rule.next || rule.push];\n            textAfter = textAfter.slice(m[0].length);\n            continue scan;\n          }\n        }\n      }\n      break;\n    }\n    return pos < 0 ? 0 : state.indent[pos];\n  };\n}","map":{"version":3,"names":["simpleMode","states","ensureState","states_","meta","languageData","hasIndentation","state","hasOwnProperty","list","orig","i","length","data","push","Rule","indent","dedent","name","startState","pending","copyState","s","slice","stack","token","tokenFunction","indentFunction","Error","toRegex","val","caret","flags","RegExp","ignoreCase","source","String","asToken","apply","replace","result","next","regex","stream","pend","shift","pos","text","curState","rule","matches","sol","match","pop","indentation","indentUnit","j","backUp","join","textAfter","dontIndentStates","doneIndentState","indexOf","rules","scan","dedentIfLineStart","m","exec"],"sources":["/Users/EL-CAPITAN-2016/Development/mentor/client/node_modules/@codemirror/legacy-modes/mode/simple-mode.js"],"sourcesContent":["export function simpleMode(states) {\n  ensureState(states, \"start\");\n  var states_ = {}, meta = states.languageData || {}, hasIndentation = false;\n  for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n    var list = states_[state] = [], orig = states[state];\n    for (var i = 0; i < orig.length; i++) {\n      var data = orig[i];\n      list.push(new Rule(data, states));\n      if (data.indent || data.dedent) hasIndentation = true;\n    }\n  }\n  return {\n    name: meta.name,\n    startState: function() {\n      return {state: \"start\", pending: null, indent: hasIndentation ? [] : null};\n    },\n    copyState: function(state) {\n      var s = {state: state.state, pending: state.pending, indent: state.indent && state.indent.slice(0)};\n      if (state.stack)\n        s.stack = state.stack.slice(0);\n      return s;\n    },\n    token: tokenFunction(states_),\n    indent: indentFunction(states_, meta),\n    languageData: meta\n  }\n};\n\nfunction ensureState(states, name) {\n  if (!states.hasOwnProperty(name))\n    throw new Error(\"Undefined state \" + name + \" in simple mode\");\n}\n\nfunction toRegex(val, caret) {\n  if (!val) return /(?:)/;\n  var flags = \"\";\n  if (val instanceof RegExp) {\n    if (val.ignoreCase) flags = \"i\";\n    val = val.source;\n  } else {\n    val = String(val);\n  }\n  return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n}\n\nfunction asToken(val) {\n  if (!val) return null;\n  if (val.apply) return val\n  if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n  var result = [];\n  for (var i = 0; i < val.length; i++)\n    result.push(val[i] && val[i].replace(/\\./g, \" \"));\n  return result;\n}\n\nfunction Rule(data, states) {\n  if (data.next || data.push) ensureState(states, data.next || data.push);\n  this.regex = toRegex(data.regex);\n  this.token = asToken(data.token);\n  this.data = data;\n}\n\nfunction tokenFunction(states) {\n  return function(stream, state) {\n    if (state.pending) {\n      var pend = state.pending.shift();\n      if (state.pending.length == 0) state.pending = null;\n      stream.pos += pend.text.length;\n      return pend.token;\n    }\n\n    var curState = states[state.state];\n    for (var i = 0; i < curState.length; i++) {\n      var rule = curState[i];\n      var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n      if (matches) {\n        if (rule.data.next) {\n          state.state = rule.data.next;\n        } else if (rule.data.push) {\n          (state.stack || (state.stack = [])).push(state.state);\n          state.state = rule.data.push;\n        } else if (rule.data.pop && state.stack && state.stack.length) {\n          state.state = state.stack.pop();\n        }\n\n        if (rule.data.indent)\n          state.indent.push(stream.indentation() + stream.indentUnit);\n        if (rule.data.dedent)\n          state.indent.pop();\n        var token = rule.token\n        if (token && token.apply) token = token(matches)\n        if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n          state.pending = [];\n          for (var j = 2; j < matches.length; j++)\n            if (matches[j])\n              state.pending.push({text: matches[j], token: rule.token[j - 1]});\n          stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n          return token[0];\n        } else if (token && token.join) {\n          return token[0];\n        } else {\n          return token;\n        }\n      }\n    }\n    stream.next();\n    return null;\n  };\n}\n\nfunction indentFunction(states, meta) {\n  return function(state, textAfter) {\n    if (state.indent == null || meta.dontIndentStates && meta.doneIndentState.indexOf(state.state) > -1)\n      return null\n\n    var pos = state.indent.length - 1, rules = states[state.state];\n    scan: for (;;) {\n      for (var i = 0; i < rules.length; i++) {\n        var rule = rules[i];\n        if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n          var m = rule.regex.exec(textAfter);\n          if (m && m[0]) {\n            pos--;\n            if (rule.next || rule.push) rules = states[rule.next || rule.push];\n            textAfter = textAfter.slice(m[0].length);\n            continue scan;\n          }\n        }\n      }\n      break;\n    }\n    return pos < 0 ? 0 : state.indent[pos];\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
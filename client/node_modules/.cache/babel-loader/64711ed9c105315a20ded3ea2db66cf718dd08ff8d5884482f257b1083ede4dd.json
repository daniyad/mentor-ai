{"ast":null,"code":"import { LanguageSupport, StreamLanguage } from '@codemirror/language';\n\n/**\n* Wrapper around the legacy CM5 Solidity language mode\n* See: https://github.com/alincode/codemirror-solidity\n*/\nconst keywords = {\n  pragma: true,\n  solidity: true,\n  import: true,\n  as: true,\n  from: true,\n  contract: true,\n  constructor: true,\n  is: true,\n  function: true,\n  modifier: true,\n  // modifiers\n  pure: true,\n  view: true,\n  payable: true,\n  constant: true,\n  anonymous: true,\n  indexed: true,\n  returns: true,\n  return: true,\n  event: true,\n  struct: true,\n  mapping: true,\n  interface: true,\n  using: true,\n  library: true,\n  storage: true,\n  memory: true,\n  calldata: true,\n  public: true,\n  private: true,\n  external: true,\n  internal: true,\n  emit: true,\n  assembly: true,\n  abstract: true,\n  after: true,\n  catch: true,\n  final: true,\n  in: true,\n  inline: true,\n  let: true,\n  match: true,\n  null: true,\n  of: true,\n  relocatable: true,\n  static: true,\n  try: true,\n  typeof: true,\n  var: true\n};\nconst keywordsSpecial = {\n  pragma: true,\n  returns: true,\n  address: true,\n  contract: true,\n  function: true,\n  struct: true\n};\nconst keywordsEtherUnit = {\n  wei: true,\n  szabo: true,\n  finney: true,\n  ether: true\n};\nconst keywordsTimeUnit = {\n  seconds: true,\n  minutes: true,\n  hours: true,\n  days: true,\n  weeks: true\n};\nconst keywordsBlockAndTransactionProperties = {\n  block: ['coinbase', 'difficulty', 'gaslimit', 'number', 'timestamp'],\n  msg: ['data', 'sender', 'sig', 'value'],\n  tx: ['gasprice', 'origin']\n};\nconst keywordsMoreBlockAndTransactionProperties = {\n  now: true,\n  gasleft: true,\n  blockhash: true\n};\nconst keywordsErrorHandling = {\n  assert: true,\n  require: true,\n  revert: true,\n  throw: true\n};\nconst keywordsMathematicalAndCryptographicFuctions = {\n  addmod: true,\n  mulmod: true,\n  keccak256: true,\n  sha256: true,\n  ripemd160: true,\n  ecrecover: true\n};\nconst keywordsContractRelated = {\n  this: true,\n  selfdestruct: true,\n  super: true\n};\nconst keywordsTypeInformation = {\n  type: true\n};\nconst keywordsContractList = {};\nconst keywordsControlStructures = {\n  if: true,\n  else: true,\n  while: true,\n  do: true,\n  for: true,\n  break: true,\n  continue: true,\n  switch: true,\n  case: true,\n  default: true\n};\nconst keywordsValueTypes = {\n  bool: true,\n  byte: true,\n  string: true,\n  enum: true,\n  address: true\n};\nconst keywordsV0505NewReserve = {\n  alias: true,\n  apply: true,\n  auto: true,\n  copyof: true,\n  define: true,\n  immutable: true,\n  implements: true,\n  macro: true,\n  mutable: true,\n  override: true,\n  partial: true,\n  promise: true,\n  reference: true,\n  sealed: true,\n  sizeof: true,\n  supports: true,\n  typedef: true,\n  unchecked: true\n};\nconst keywordsAbiEncodeDecodeFunctions = {\n  abi: ['decode', 'encodePacked', 'encodeWithSelector', 'encodeWithSignature', 'encode']\n};\nconst keywordsMembersOfAddressType = ['transfer', 'send', 'balance', 'call', 'delegatecall', 'staticcall'];\nconst natSpecTags = ['title', 'author', 'notice', 'dev', 'param', 'return'];\nconst atoms = {\n  delete: true,\n  new: true,\n  true: true,\n  false: true\n};\nconst isOperatorChar = /[+\\-*&^%:=<>!|/~]/;\nconst isNegativeChar = /[-]/;\nlet curPunc;\nfunction tokenBase(stream, state) {\n  let ch = stream.next();\n  if (ch === '\"' || ch === \"'\" || ch === '`') {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (isVersion(stream, state)) {\n    return 'version';\n  }\n  if (ch === '.' && keywordsMembersOfAddressType.some(function (item) {\n    return stream.match(\"\".concat(item));\n  })) {\n    return 'addressFunction';\n  }\n  if (typeof ch === 'string' && isNumber(ch, stream)) {\n    return 'number';\n  }\n  if (typeof ch === 'string' && /[[\\]{}(),;:.]/.test(ch)) {\n    return updateGarmmer(ch, state);\n  }\n  if (ch === '/') {\n    if (stream.eat('*')) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n    if (stream.match(/\\/{2}/)) {\n      ch = stream.next();\n      while (ch) {\n        if (ch === '@') {\n          stream.backUp(1);\n          state.grammar = 'doc';\n          break;\n        }\n        ch = stream.next();\n      }\n      return 'doc';\n    }\n    if (stream.eat('/')) {\n      stream.skipToEnd();\n      return 'comment';\n    }\n  }\n  if (typeof ch === 'string' && isNegativeChar.test(ch)) {\n    const peeked = stream.peek();\n    if (typeof peeked === 'string' && isNumber(peeked, stream)) {\n      return 'number';\n    }\n    return 'operator';\n  }\n  if (typeof ch === 'string' && isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return 'operator';\n  }\n  stream.eatWhile(/[\\w$_\\xa1-\\uffff]/);\n  const cur = stream.current();\n  if (state.grammar === 'doc') {\n    if (natSpecTags.some(function (item) {\n      return cur === \"@\".concat(item);\n    })) {\n      return 'docReserve';\n    }\n    return 'doc';\n  }\n  if (cur === 'solidity' && state.lastToken === 'pragma') {\n    state.lastToken = state.lastToken + ' ' + cur;\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywords, cur)) {\n    if (cur === 'case' || cur === 'default') {\n      curPunc = 'case';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsSpecial, cur)) {\n      state.lastToken = cur;\n    }\n    //if (cur === 'function' && state.para === 'parameterMode')\n    return 'keyword';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsEtherUnit, cur)) {\n    return 'etherUnit';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsContractRelated, cur)) {\n    return 'contractRelated';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsControlStructures, cur) || Object.prototype.propertyIsEnumerable.call(keywordsTypeInformation, cur) || Object.prototype.propertyIsEnumerable.call(keywordsV0505NewReserve, cur)) {\n    return 'keyword';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsValueTypes, cur) || Object.prototype.propertyIsEnumerable.call(keywordsTimeUnit, cur) || isValidInteger(cur) || isValidBytes(cur) || isValidFixed(cur)) {\n    state.lastToken += 'variable';\n    return 'keyword';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(atoms, cur)) {\n    return 'atom';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsErrorHandling, cur)) {\n    return 'errorHandling';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsMathematicalAndCryptographicFuctions, cur)) {\n    return 'mathematicalAndCryptographic';\n  }\n  if (Object.prototype.propertyIsEnumerable.call(keywordsMoreBlockAndTransactionProperties, cur) || Object.prototype.propertyIsEnumerable.call(keywordsBlockAndTransactionProperties, cur) && keywordsBlockAndTransactionProperties[cur].some(function (item) {\n    return stream.match(\".\".concat(item));\n  })) {\n    return 'variable-2';\n  }\n  if (cur === 'abi' && keywordsAbiEncodeDecodeFunctions[cur].some(function (item) {\n    return stream.match(\".\".concat(item));\n  })) {\n    return 'abi';\n  }\n  const style = updateHexLiterals(cur, stream);\n  if (style != null) {\n    return style;\n  }\n  if ((state.lastToken === 'functionName(' || state.lastToken === 'returns(') && Object.prototype.propertyIsEnumerable.call(keywordsContractList, cur)) {\n    state.lastToken += 'variable';\n    return 'variable';\n  }\n  if (state.lastToken === 'function') {\n    state.lastToken = 'functionName';\n    if (state.para == null) {\n      state.grammar = 'function';\n      state.para = '';\n    }\n    //state.parasMode = isNaN(state.parasMode) ? 1 : state.functionLayerCount++;\n    state.para += 'functionName';\n    return 'functionName';\n  }\n  if (state.lastToken === 'functionName(variable') {\n    state.lastToken = 'functionName(';\n    return 'parameterValue';\n  }\n  if (state.lastToken === 'returns(variable') {\n    state.lastToken = 'returns(';\n    return 'parameterValue';\n  }\n  if (state.lastToken === 'address' && cur === 'payable') {\n    state.lastToken = 'address payable';\n  }\n  if (state.lastToken === 'contract' || state.lastToken === 'struct') {\n    keywordsContractList[cur] = true;\n    state.lastToken = null;\n  }\n  if (state.grammar === 'function') {\n    return 'parameterValue';\n  }\n  return 'variable';\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    let escaped = false;\n    let next;\n    let end = false;\n    next = stream.next();\n    while (next != null) {\n      if (next === quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && quote !== '`' && next === '\\\\';\n      next = stream.next();\n    }\n    if (end || !(escaped || quote === '`')) {\n      state.tokenize = tokenBase;\n    }\n    return 'string';\n  };\n}\nfunction tokenComment(stream, state) {\n  let maybeEnd = false;\n  let ch = stream.next();\n  while (ch) {\n    if (ch === '/' && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch === '*';\n    ch = stream.next();\n  }\n  return 'comment';\n}\nfunction isVersion(stream, state) {\n  if (state.lastToken === 'pragma solidity') {\n    state.lastToken = null;\n    return !state.startOfLine && (stream.match(/[\\^{0}][0-9.]+/) || stream.match(/[>=]+?[\\s]*[0-9.]+[\\s]*[<]?[\\s]*[0-9.]+/));\n  }\n}\nfunction isNumber(ch, stream) {\n  if (/[\\d.]/.test(ch)) {\n    if (ch === '.') {\n      stream.match(/^[0-9]+([eE][-+]?[0-9]+)?/);\n    } else if (ch === '0') {\n      if (!stream.match(/^[xX][0-9a-fA-F]+/)) {\n        stream.match(/^0[0-7]+/);\n      }\n    } else {\n      stream.match(/^[0-9]*\\.?[0-9]*([eE][-+]?[0-9]+)?/);\n    }\n    return true;\n  }\n}\nfunction isValidInteger(token) {\n  if (token.match(/^[u]?int/)) {\n    if (token.indexOf('t') + 1 === token.length) {\n      return true;\n    }\n    const numberPart = Number(token.substr(token.indexOf('t') + 1, token.length));\n    return numberPart % 8 === 0 && numberPart <= 256;\n  }\n}\nfunction isValidBytes(token) {\n  if (token.match(/^bytes/)) {\n    if (token.indexOf('s') + 1 === token.length) {\n      return true;\n    }\n    const bytesPart = token.substr(token.indexOf('s') + 1, token.length);\n    return Number(bytesPart) <= 32;\n  }\n}\nfunction isValidFixed(token) {\n  if (token.match(/^[u]?fixed([0-9]+x[0-9]+)?/)) {\n    if (token.indexOf('d') + 1 === token.length) {\n      return true;\n    }\n    const numberPart = token.substr(token.indexOf('d') + 1, token.length).split('x').map(Number);\n    return numberPart[0] % 8 === 0 && numberPart[0] <= 256 && numberPart[1] <= 80;\n  }\n}\nfunction updateHexLiterals(token, stream) {\n  if (token.match(/^hex/) && stream.peek() === '\"') {\n    let maybeEnd = false;\n    let ch;\n    let hexValue = '';\n    let stringAfterHex = '';\n    ch = stream.next();\n    while (ch) {\n      stringAfterHex += ch;\n      if (ch === '\"' && maybeEnd) {\n        hexValue = stringAfterHex.substring(1, stringAfterHex.length - 1);\n        if (hexValue.match(/^[0-9a-fA-F]+$/)) {\n          return 'number';\n        }\n        stream.backUp(stringAfterHex.length);\n        break;\n      }\n      maybeEnd = maybeEnd || ch === '\"';\n      ch = stream.next();\n    }\n  }\n}\nfunction updateGarmmer(ch, state) {\n  if (ch === ',' && state.para === 'functionName(variable') {\n    state.para = 'functionName(';\n  }\n  if (state.para != null && state.para.startsWith('functionName')) {\n    if (ch === ')') {\n      if (state.para.endsWith('(')) {\n        state.para = state.para.substr(0, state.para.length - 1);\n        if (state.para === 'functionName') {\n          state.grammar = '';\n        }\n      }\n    } else if (ch === '(') {\n      state.para += ch;\n    }\n  }\n  if (ch === '(' && state.lastToken === 'functionName') {\n    state.lastToken += ch;\n  } else if (ch === ')' && state.lastToken === 'functionName(') {\n    state.lastToken = null;\n  } else if (ch === '(' && state.lastToken === 'returns') {\n    state.lastToken += ch;\n  } else if (ch === ')' && (state.lastToken === 'returns(' || state.lastToken === 'returns(variable')) {\n    state.lastToken = null;\n  }\n  if (ch === '(' && state.lastToken === 'address') {\n    state.lastToken += ch;\n  }\n  curPunc = ch;\n  return null;\n}\nclass Context {\n  constructor(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n}\nfunction pushContext(state, col, type) {\n  state.context = new Context(state.indented, col, type, null, state.context);\n  return state.context;\n}\nfunction popContext(state) {\n  if (!state.context.prev) {\n    return;\n  }\n  const t = state.context.type;\n  if (t === ')' || t === ']' || t === '}') {\n    state.indented = state.context.indented;\n  }\n  return state.context = state.context.prev;\n}\nconst parser = {\n  startState(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(0 - indentUnit, 0, 'top', false, null),\n      indented: 0,\n      startOfLine: true,\n      grammar: null,\n      lastToken: null,\n      para: null\n    };\n  },\n  token(stream, state) {\n    const ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) {\n        ctx.align = false;\n      }\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n      if (ctx.type === 'case') {\n        ctx.type = '}';\n      }\n      if (state.grammar === 'doc') {\n        state.grammar = null;\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n    curPunc = null;\n    const style = (state.tokenize || tokenBase)(stream, state);\n    if (style === 'comment') {\n      return style;\n    }\n    if (ctx.align == null) {\n      ctx.align = true;\n    }\n    if (curPunc === '{') {\n      pushContext(state, stream.column(), '}');\n    } else if (curPunc === '[') {\n      pushContext(state, stream.column(), ']');\n    } else if (curPunc === '(') {\n      pushContext(state, stream.column(), ')');\n    } else if (curPunc === 'case') {\n      ctx.type = 'case';\n    } else if (curPunc === '}' && ctx.type === '}') {\n      popContext(state);\n    } else if (curPunc === ctx.type) {\n      popContext(state);\n    }\n    state.startOfLine = false;\n    return style;\n  },\n  indent(state, textAfter, indentContext) {\n    if (state.tokenize !== tokenBase && state.tokenize != null) {\n      return null;\n    }\n    const ctx = state.context;\n    const firstChar = textAfter && textAfter.charAt(0);\n    if (ctx.type === 'case' && /^(?:case|default)\\b/.test(textAfter)) {\n      state.context.type = '}';\n      return ctx.indented;\n    }\n    const closing = firstChar === ctx.type;\n    if (ctx.align) {\n      return ctx.column + (closing ? 0 : 1);\n    }\n    return ctx.indented + (closing ? 0 : indentContext.unit);\n  },\n  // @ts-ignore not specified in new stream parser, but maybe does something\n  electricChars: '{}):',\n  closeBrackets: '()[]{}\\'\\'\"\"``',\n  fold: 'brace',\n  blockCommentStart: '/*',\n  blockCommentEnd: '*/',\n  lineComment: '//'\n};\nconst solidity = /*@__PURE__*/new LanguageSupport( /*@__PURE__*/StreamLanguage.define(parser));\nexport { parser, solidity };","map":{"version":3,"names":["LanguageSupport","StreamLanguage","keywords","pragma","solidity","import","as","from","contract","constructor","is","function","modifier","pure","view","payable","constant","anonymous","indexed","returns","return","event","struct","mapping","interface","using","library","storage","memory","calldata","public","private","external","internal","emit","assembly","abstract","after","catch","final","in","inline","let","match","null","of","relocatable","static","try","typeof","var","keywordsSpecial","address","keywordsEtherUnit","wei","szabo","finney","ether","keywordsTimeUnit","seconds","minutes","hours","days","weeks","keywordsBlockAndTransactionProperties","block","msg","tx","keywordsMoreBlockAndTransactionProperties","now","gasleft","blockhash","keywordsErrorHandling","assert","require","revert","throw","keywordsMathematicalAndCryptographicFuctions","addmod","mulmod","keccak256","sha256","ripemd160","ecrecover","keywordsContractRelated","this","selfdestruct","super","keywordsTypeInformation","type","keywordsContractList","keywordsControlStructures","if","else","while","do","for","break","continue","switch","case","default","keywordsValueTypes","bool","byte","string","enum","keywordsV0505NewReserve","alias","apply","auto","copyof","define","immutable","implements","macro","mutable","override","partial","promise","reference","sealed","sizeof","supports","typedef","unchecked","keywordsAbiEncodeDecodeFunctions","abi","keywordsMembersOfAddressType","natSpecTags","atoms","delete","new","true","false","isOperatorChar","isNegativeChar","curPunc","tokenBase","stream","state","ch","next","tokenize","tokenString","isVersion","some","item","concat","isNumber","test","updateGarmmer","eat","tokenComment","backUp","grammar","skipToEnd","peeked","peek","eatWhile","cur","current","lastToken","Object","prototype","propertyIsEnumerable","call","isValidInteger","isValidBytes","isValidFixed","style","updateHexLiterals","para","quote","escaped","end","maybeEnd","startOfLine","token","indexOf","length","numberPart","Number","substr","bytesPart","split","map","hexValue","stringAfterHex","substring","startsWith","endsWith","Context","indented","column","align","prev","pushContext","col","context","popContext","t","parser","startState","indentUnit","ctx","sol","indentation","eatSpace","indent","textAfter","indentContext","firstChar","charAt","closing","unit","electricChars","closeBrackets","fold","blockCommentStart","blockCommentEnd","lineComment"],"sources":["/Users/EL-CAPITAN-2016/Development/mentor/client/node_modules/@replit/codemirror-lang-solidity/dist/index.js"],"sourcesContent":["import { LanguageSupport, StreamLanguage } from '@codemirror/language';\n\n/**\n* Wrapper around the legacy CM5 Solidity language mode\n* See: https://github.com/alincode/codemirror-solidity\n*/\nconst keywords = {\n    pragma: true,\n    solidity: true,\n    import: true,\n    as: true,\n    from: true,\n    contract: true,\n    constructor: true,\n    is: true,\n    function: true,\n    modifier: true,\n    // modifiers\n    pure: true,\n    view: true,\n    payable: true,\n    constant: true,\n    anonymous: true,\n    indexed: true,\n    returns: true,\n    return: true,\n    event: true,\n    struct: true,\n    mapping: true,\n    interface: true,\n    using: true,\n    library: true,\n    storage: true,\n    memory: true,\n    calldata: true,\n    public: true,\n    private: true,\n    external: true,\n    internal: true,\n    emit: true,\n    assembly: true,\n    abstract: true,\n    after: true,\n    catch: true,\n    final: true,\n    in: true,\n    inline: true,\n    let: true,\n    match: true,\n    null: true,\n    of: true,\n    relocatable: true,\n    static: true,\n    try: true,\n    typeof: true,\n    var: true,\n};\nconst keywordsSpecial = {\n    pragma: true,\n    returns: true,\n    address: true,\n    contract: true,\n    function: true,\n    struct: true,\n};\nconst keywordsEtherUnit = {\n    wei: true,\n    szabo: true,\n    finney: true,\n    ether: true,\n};\nconst keywordsTimeUnit = {\n    seconds: true,\n    minutes: true,\n    hours: true,\n    days: true,\n    weeks: true,\n};\nconst keywordsBlockAndTransactionProperties = {\n    block: ['coinbase', 'difficulty', 'gaslimit', 'number', 'timestamp'],\n    msg: ['data', 'sender', 'sig', 'value'],\n    tx: ['gasprice', 'origin'],\n};\nconst keywordsMoreBlockAndTransactionProperties = {\n    now: true,\n    gasleft: true,\n    blockhash: true,\n};\nconst keywordsErrorHandling = {\n    assert: true,\n    require: true,\n    revert: true,\n    throw: true,\n};\nconst keywordsMathematicalAndCryptographicFuctions = {\n    addmod: true,\n    mulmod: true,\n    keccak256: true,\n    sha256: true,\n    ripemd160: true,\n    ecrecover: true,\n};\nconst keywordsContractRelated = {\n    this: true,\n    selfdestruct: true,\n    super: true,\n};\nconst keywordsTypeInformation = { type: true };\nconst keywordsContractList = {};\nconst keywordsControlStructures = {\n    if: true,\n    else: true,\n    while: true,\n    do: true,\n    for: true,\n    break: true,\n    continue: true,\n    switch: true,\n    case: true,\n    default: true,\n};\nconst keywordsValueTypes = {\n    bool: true,\n    byte: true,\n    string: true,\n    enum: true,\n    address: true,\n};\nconst keywordsV0505NewReserve = {\n    alias: true,\n    apply: true,\n    auto: true,\n    copyof: true,\n    define: true,\n    immutable: true,\n    implements: true,\n    macro: true,\n    mutable: true,\n    override: true,\n    partial: true,\n    promise: true,\n    reference: true,\n    sealed: true,\n    sizeof: true,\n    supports: true,\n    typedef: true,\n    unchecked: true,\n};\nconst keywordsAbiEncodeDecodeFunctions = {\n    abi: [\n        'decode',\n        'encodePacked',\n        'encodeWithSelector',\n        'encodeWithSignature',\n        'encode',\n    ],\n};\nconst keywordsMembersOfAddressType = [\n    'transfer',\n    'send',\n    'balance',\n    'call',\n    'delegatecall',\n    'staticcall',\n];\nconst natSpecTags = ['title', 'author', 'notice', 'dev', 'param', 'return'];\nconst atoms = {\n    delete: true,\n    new: true,\n    true: true,\n    false: true,\n};\nconst isOperatorChar = /[+\\-*&^%:=<>!|/~]/;\nconst isNegativeChar = /[-]/;\nlet curPunc;\nfunction tokenBase(stream, state) {\n    let ch = stream.next();\n    if (ch === '\"' || ch === \"'\" || ch === '`') {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n    }\n    if (isVersion(stream, state)) {\n        return 'version';\n    }\n    if (ch === '.' &&\n        keywordsMembersOfAddressType.some(function (item) {\n            return stream.match(`${item}`);\n        })) {\n        return 'addressFunction';\n    }\n    if (typeof ch === 'string' && isNumber(ch, stream)) {\n        return 'number';\n    }\n    if (typeof ch === 'string' && /[[\\]{}(),;:.]/.test(ch)) {\n        return updateGarmmer(ch, state);\n    }\n    if (ch === '/') {\n        if (stream.eat('*')) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n        }\n        if (stream.match(/\\/{2}/)) {\n            ch = stream.next();\n            while (ch) {\n                if (ch === '@') {\n                    stream.backUp(1);\n                    state.grammar = 'doc';\n                    break;\n                }\n                ch = stream.next();\n            }\n            return 'doc';\n        }\n        if (stream.eat('/')) {\n            stream.skipToEnd();\n            return 'comment';\n        }\n    }\n    if (typeof ch === 'string' && isNegativeChar.test(ch)) {\n        const peeked = stream.peek();\n        if (typeof peeked === 'string' && isNumber(peeked, stream)) {\n            return 'number';\n        }\n        return 'operator';\n    }\n    if (typeof ch === 'string' && isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return 'operator';\n    }\n    stream.eatWhile(/[\\w$_\\xa1-\\uffff]/);\n    const cur = stream.current();\n    if (state.grammar === 'doc') {\n        if (natSpecTags.some(function (item) {\n            return cur === `@${item}`;\n        })) {\n            return 'docReserve';\n        }\n        return 'doc';\n    }\n    if (cur === 'solidity' && state.lastToken === 'pragma') {\n        state.lastToken = state.lastToken + ' ' + cur;\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywords, cur)) {\n        if (cur === 'case' || cur === 'default') {\n            curPunc = 'case';\n        }\n        if (Object.prototype.propertyIsEnumerable.call(keywordsSpecial, cur)) {\n            state.lastToken = cur;\n        }\n        //if (cur === 'function' && state.para === 'parameterMode')\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsEtherUnit, cur)) {\n        return 'etherUnit';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsContractRelated, cur)) {\n        return 'contractRelated';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsControlStructures, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsTypeInformation, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsV0505NewReserve, cur)) {\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsValueTypes, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsTimeUnit, cur) ||\n        isValidInteger(cur) ||\n        isValidBytes(cur) ||\n        isValidFixed(cur)) {\n        state.lastToken += 'variable';\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(atoms, cur)) {\n        return 'atom';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsErrorHandling, cur)) {\n        return 'errorHandling';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsMathematicalAndCryptographicFuctions, cur)) {\n        return 'mathematicalAndCryptographic';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsMoreBlockAndTransactionProperties, cur) ||\n        (Object.prototype.propertyIsEnumerable.call(keywordsBlockAndTransactionProperties, cur) &&\n            keywordsBlockAndTransactionProperties[cur].some(function (item) {\n                return stream.match(`.${item}`);\n            }))) {\n        return 'variable-2';\n    }\n    if (cur === 'abi' &&\n        keywordsAbiEncodeDecodeFunctions[cur].some(function (item) {\n            return stream.match(`.${item}`);\n        })) {\n        return 'abi';\n    }\n    const style = updateHexLiterals(cur, stream);\n    if (style != null) {\n        return style;\n    }\n    if ((state.lastToken === 'functionName(' || state.lastToken === 'returns(') &&\n        Object.prototype.propertyIsEnumerable.call(keywordsContractList, cur)) {\n        state.lastToken += 'variable';\n        return 'variable';\n    }\n    if (state.lastToken === 'function') {\n        state.lastToken = 'functionName';\n        if (state.para == null) {\n            state.grammar = 'function';\n            state.para = '';\n        }\n        //state.parasMode = isNaN(state.parasMode) ? 1 : state.functionLayerCount++;\n        state.para += 'functionName';\n        return 'functionName';\n    }\n    if (state.lastToken === 'functionName(variable') {\n        state.lastToken = 'functionName(';\n        return 'parameterValue';\n    }\n    if (state.lastToken === 'returns(variable') {\n        state.lastToken = 'returns(';\n        return 'parameterValue';\n    }\n    if (state.lastToken === 'address' && cur === 'payable') {\n        state.lastToken = 'address payable';\n    }\n    if (state.lastToken === 'contract' || state.lastToken === 'struct') {\n        keywordsContractList[cur] = true;\n        state.lastToken = null;\n    }\n    if (state.grammar === 'function') {\n        return 'parameterValue';\n    }\n    return 'variable';\n}\nfunction tokenString(quote) {\n    return function (stream, state) {\n        let escaped = false;\n        let next;\n        let end = false;\n        next = stream.next();\n        while (next != null) {\n            if (next === quote && !escaped) {\n                end = true;\n                break;\n            }\n            escaped = !escaped && quote !== '`' && next === '\\\\';\n            next = stream.next();\n        }\n        if (end || !(escaped || quote === '`')) {\n            state.tokenize = tokenBase;\n        }\n        return 'string';\n    };\n}\nfunction tokenComment(stream, state) {\n    let maybeEnd = false;\n    let ch = stream.next();\n    while (ch) {\n        if (ch === '/' && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n        }\n        maybeEnd = ch === '*';\n        ch = stream.next();\n    }\n    return 'comment';\n}\nfunction isVersion(stream, state) {\n    if (state.lastToken === 'pragma solidity') {\n        state.lastToken = null;\n        return (!state.startOfLine &&\n            (stream.match(/[\\^{0}][0-9.]+/) ||\n                stream.match(/[>=]+?[\\s]*[0-9.]+[\\s]*[<]?[\\s]*[0-9.]+/)));\n    }\n}\nfunction isNumber(ch, stream) {\n    if (/[\\d.]/.test(ch)) {\n        if (ch === '.') {\n            stream.match(/^[0-9]+([eE][-+]?[0-9]+)?/);\n        }\n        else if (ch === '0') {\n            if (!stream.match(/^[xX][0-9a-fA-F]+/)) {\n                stream.match(/^0[0-7]+/);\n            }\n        }\n        else {\n            stream.match(/^[0-9]*\\.?[0-9]*([eE][-+]?[0-9]+)?/);\n        }\n        return true;\n    }\n}\nfunction isValidInteger(token) {\n    if (token.match(/^[u]?int/)) {\n        if (token.indexOf('t') + 1 === token.length) {\n            return true;\n        }\n        const numberPart = Number(token.substr(token.indexOf('t') + 1, token.length));\n        return numberPart % 8 === 0 && numberPart <= 256;\n    }\n}\nfunction isValidBytes(token) {\n    if (token.match(/^bytes/)) {\n        if (token.indexOf('s') + 1 === token.length) {\n            return true;\n        }\n        const bytesPart = token.substr(token.indexOf('s') + 1, token.length);\n        return Number(bytesPart) <= 32;\n    }\n}\nfunction isValidFixed(token) {\n    if (token.match(/^[u]?fixed([0-9]+x[0-9]+)?/)) {\n        if (token.indexOf('d') + 1 === token.length) {\n            return true;\n        }\n        const numberPart = token\n            .substr(token.indexOf('d') + 1, token.length)\n            .split('x')\n            .map(Number);\n        return (numberPart[0] % 8 === 0 && numberPart[0] <= 256 && numberPart[1] <= 80);\n    }\n}\nfunction updateHexLiterals(token, stream) {\n    if (token.match(/^hex/) && stream.peek() === '\"') {\n        let maybeEnd = false;\n        let ch;\n        let hexValue = '';\n        let stringAfterHex = '';\n        ch = stream.next();\n        while (ch) {\n            stringAfterHex += ch;\n            if (ch === '\"' && maybeEnd) {\n                hexValue = stringAfterHex.substring(1, stringAfterHex.length - 1);\n                if (hexValue.match(/^[0-9a-fA-F]+$/)) {\n                    return 'number';\n                }\n                stream.backUp(stringAfterHex.length);\n                break;\n            }\n            maybeEnd = maybeEnd || ch === '\"';\n            ch = stream.next();\n        }\n    }\n}\nfunction updateGarmmer(ch, state) {\n    if (ch === ',' && state.para === 'functionName(variable') {\n        state.para = 'functionName(';\n    }\n    if (state.para != null && state.para.startsWith('functionName')) {\n        if (ch === ')') {\n            if (state.para.endsWith('(')) {\n                state.para = state.para.substr(0, state.para.length - 1);\n                if (state.para === 'functionName') {\n                    state.grammar = '';\n                }\n            }\n        }\n        else if (ch === '(') {\n            state.para += ch;\n        }\n    }\n    if (ch === '(' && state.lastToken === 'functionName') {\n        state.lastToken += ch;\n    }\n    else if (ch === ')' && state.lastToken === 'functionName(') {\n        state.lastToken = null;\n    }\n    else if (ch === '(' && state.lastToken === 'returns') {\n        state.lastToken += ch;\n    }\n    else if (ch === ')' &&\n        (state.lastToken === 'returns(' || state.lastToken === 'returns(variable')) {\n        state.lastToken = null;\n    }\n    if (ch === '(' && state.lastToken === 'address') {\n        state.lastToken += ch;\n    }\n    curPunc = ch;\n    return null;\n}\nclass Context {\n    constructor(indented, column, type, align, prev) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type;\n        this.align = align;\n        this.prev = prev;\n    }\n}\nfunction pushContext(state, col, type) {\n    state.context = new Context(state.indented, col, type, null, state.context);\n    return state.context;\n}\nfunction popContext(state) {\n    if (!state.context.prev) {\n        return;\n    }\n    const t = state.context.type;\n    if (t === ')' || t === ']' || t === '}') {\n        state.indented = state.context.indented;\n    }\n    return (state.context = state.context.prev);\n}\nconst parser = {\n    startState(indentUnit) {\n        return {\n            tokenize: null,\n            context: new Context(0 - indentUnit, 0, 'top', false, null),\n            indented: 0,\n            startOfLine: true,\n            grammar: null,\n            lastToken: null,\n            para: null,\n        };\n    },\n    token(stream, state) {\n        const ctx = state.context;\n        if (stream.sol()) {\n            if (ctx.align == null) {\n                ctx.align = false;\n            }\n            state.indented = stream.indentation();\n            state.startOfLine = true;\n            if (ctx.type === 'case') {\n                ctx.type = '}';\n            }\n            if (state.grammar === 'doc') {\n                state.grammar = null;\n            }\n        }\n        if (stream.eatSpace()) {\n            return null;\n        }\n        curPunc = null;\n        const style = (state.tokenize || tokenBase)(stream, state);\n        if (style === 'comment') {\n            return style;\n        }\n        if (ctx.align == null) {\n            ctx.align = true;\n        }\n        if (curPunc === '{') {\n            pushContext(state, stream.column(), '}');\n        }\n        else if (curPunc === '[') {\n            pushContext(state, stream.column(), ']');\n        }\n        else if (curPunc === '(') {\n            pushContext(state, stream.column(), ')');\n        }\n        else if (curPunc === 'case') {\n            ctx.type = 'case';\n        }\n        else if (curPunc === '}' && ctx.type === '}') {\n            popContext(state);\n        }\n        else if (curPunc === ctx.type) {\n            popContext(state);\n        }\n        state.startOfLine = false;\n        return style;\n    },\n    indent(state, textAfter, indentContext) {\n        if (state.tokenize !== tokenBase && state.tokenize != null) {\n            return null;\n        }\n        const ctx = state.context;\n        const firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type === 'case' && /^(?:case|default)\\b/.test(textAfter)) {\n            state.context.type = '}';\n            return ctx.indented;\n        }\n        const closing = firstChar === ctx.type;\n        if (ctx.align) {\n            return ctx.column + (closing ? 0 : 1);\n        }\n        return ctx.indented + (closing ? 0 : indentContext.unit);\n    },\n    // @ts-ignore not specified in new stream parser, but maybe does something\n    electricChars: '{}):',\n    closeBrackets: '()[]{}\\'\\'\"\"``',\n    fold: 'brace',\n    blockCommentStart: '/*',\n    blockCommentEnd: '*/',\n    lineComment: '//',\n};\nconst solidity = /*@__PURE__*/new LanguageSupport(/*@__PURE__*/StreamLanguage.define(parser));\n\nexport { parser, solidity };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\nfunction tagName(doc, tag) {\n  let name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n  let tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n  let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n  let name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n  for (let cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == \"Element\") return cur;\n  return null;\n}\nfunction findLocation(state, pos) {\n  var _a;\n  let at = syntaxTree(state).resolveInner(pos, -1),\n    inTag = null;\n  for (let cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    let elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\nclass Element {\n  constructor(spec, attrs, attrValues) {\n    this.attrs = attrs;\n    this.attrValues = attrValues;\n    this.children = [];\n    this.name = spec.name;\n    this.completion = Object.assign(Object.assign({\n      type: \"type\"\n    }, spec.completion || {}), {\n      label: this.name\n    });\n    this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"<\" + this.name\n    });\n    this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"</\" + this.name + \">\",\n      boost: 2\n    });\n    this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: this.name + \">\"\n    });\n    this.text = spec.textContent ? spec.textContent.map(s => ({\n      label: s,\n      type: \"text\"\n    })) : [];\n  }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: \"\\\"\".concat(spec, \"\\\"\"),\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: \"\\\"\".concat(spec.label, \"\\\"\")\n  });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  let allAttrs = [],\n    globalAttrs = [];\n  let attrValues = Object.create(null);\n  for (let s of attrSpecs) {\n    let completion = attrCompletion(s);\n    allAttrs.push(completion);\n    if (s.global) globalAttrs.push(completion);\n    if (s.values) attrValues[s.name] = s.values.map(valueCompletion);\n  }\n  let allElements = [],\n    topElements = [];\n  let byName = Object.create(null);\n  for (let s of eltSpecs) {\n    let attrs = globalAttrs,\n      attrVals = attrValues;\n    if (s.attributes) attrs = attrs.concat(s.attributes.map(s => {\n      if (typeof s == \"string\") return allAttrs.find(a => a.label == s) || {\n        label: s,\n        type: \"property\"\n      };\n      if (s.values) {\n        if (attrVals == attrValues) attrVals = Object.create(attrVals);\n        attrVals[s.name] = s.values.map(valueCompletion);\n      }\n      return attrCompletion(s);\n    }));\n    let elt = new Element(s, attrs, attrVals);\n    byName[elt.name] = elt;\n    allElements.push(elt);\n    if (s.top) topElements.push(elt);\n  }\n  if (!topElements.length) topElements = allElements;\n  for (let i = 0; i < allElements.length; i++) {\n    let s = eltSpecs[i],\n      elt = allElements[i];\n    if (s.children) {\n      for (let ch of s.children) if (byName[ch]) elt.children.push(byName[ch]);\n    } else {\n      elt.children = allElements;\n    }\n  }\n  return cx => {\n    var _a;\n    let {\n        doc\n      } = cx.state,\n      loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    let {\n      type,\n      from,\n      context\n    } = loc;\n    if (type == \"openTag\") {\n      let children = topElements;\n      let parentName = elementName(doc, context);\n      if (parentName) {\n        let parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n      return {\n        from,\n        options: children.map(ch => ch.completion),\n        validFor: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      let parentName = elementName(doc, context);\n      return parentName ? {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: parentName + \">\",\n          type: \"type\"\n        }],\n        validFor: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      let parent = byName[tagName(doc, context)];\n      return {\n        from,\n        options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n        validFor: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      let attr = attrName(doc, context, from);\n      if (!attr) return null;\n      let parent = byName[tagName(doc, context)];\n      let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        validFor: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      let parentName = elementName(doc, context),\n        parent = byName[parentName];\n      let closing = [],\n        last = context && context.lastChild;\n      if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName)) closing.push(parent ? parent.closeCompletion : {\n        label: \"</\" + parentName + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n      if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n        let openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(parent.text);\n      }\n      return {\n        from,\n        options,\n        validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"xml\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Element(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"OpenTag CloseTag SelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      Element(subtree) {\n        let first = subtree.firstChild,\n          last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n    }), /*@__PURE__*/bracketMatchingHandle.add({\n      \"OpenTag CloseTag\": node => node.getChild(\"TagName\")\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml() {\n  let conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\nexport { completeFromSchema, xml, xmlLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","foldNodeProp","bracketMatchingHandle","LanguageSupport","tagName","doc","tag","name","getChild","sliceString","from","to","elementName","tree","firstChild","attrName","pos","attr","getChildren","find","a","findParentElement","cur","parent","findLocation","state","_a","at","resolveInner","inTag","lastChild","type","isError","elt","context","before","childBefore","Element","constructor","spec","attrs","attrValues","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","concat","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","push","global","values","allElements","topElements","byName","attrVals","attributes","top","length","i","ch","cx","loc","explicit","parentName","options","validFor","closing","last","e","openTag","sliceDoc","xmlLanguage","define","configure","props","add","closed","textAfter","lineIndent","node","unit","OpenTag CloseTag SelfClosingTag","column","subtree","first","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","arguments","undefined","data","of","autocomplete","elements"],"sources":["/Users/EL-CAPITAN-2016/Development/mentor/client/node_modules/@codemirror/lang-xml/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\n\nfunction tagName(doc, tag) {\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n    let tag = tree && tree.firstChild;\n    return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n    let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n    let name = attr && attr.getChild(\"AttributeName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n    for (let cur = tree && tree.parent; cur; cur = cur.parent)\n        if (cur.name == \"Element\")\n            return cur;\n    return null;\n}\nfunction findLocation(state, pos) {\n    var _a;\n    let at = syntaxTree(state).resolveInner(pos, -1), inTag = null;\n    for (let cur = at; !inTag && cur.parent; cur = cur.parent)\n        if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\")\n            inTag = cur;\n    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n        let elt = inTag.parent;\n        if (at.name == \"TagName\")\n            return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\"\n                ? { type: \"closeTag\", from: at.from, context: elt }\n                : { type: \"openTag\", from: at.from, context: findParentElement(elt) };\n        if (at.name == \"AttributeName\")\n            return { type: \"attrName\", from: at.from, context: inTag };\n        if (at.name == \"AttributeValue\")\n            return { type: \"attrValue\", from: at.from, context: inTag };\n        let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\")\n            return { type: \"openTag\", from: pos, context: findParentElement(elt) };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos)\n            return { type: \"closeTag\", from: pos, context: elt };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\")\n            return { type: \"attrValue\", from: pos, context: inTag };\n        if (before)\n            return { type: \"attrName\", from: pos, context: inTag };\n        return null;\n    }\n    else if (at.name == \"StartCloseTag\") {\n        return { type: \"closeTag\", from: pos, context: at.parent };\n    }\n    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))\n        at = at.parent;\n    if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\")\n        return { type: \"tag\", from: pos, context: at.name == \"Element\" ? at : findParentElement(at) };\n    return null;\n}\nclass Element {\n    constructor(spec, attrs, attrValues) {\n        this.attrs = attrs;\n        this.attrValues = attrValues;\n        this.children = [];\n        this.name = spec.name;\n        this.completion = Object.assign(Object.assign({ type: \"type\" }, spec.completion || {}), { label: this.name });\n        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: \"<\" + this.name });\n        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: \"</\" + this.name + \">\", boost: 2 });\n        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + \">\" });\n        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: \"text\" })) : [];\n    }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n    return Object.assign(Object.assign({ type: \"property\" }, spec.completion || {}), { label: spec.name });\n}\nfunction valueCompletion(spec) {\n    return typeof spec == \"string\" ? { label: `\"${spec}\"`, type: \"constant\" }\n        : /^\"/.test(spec.label) ? spec\n            : Object.assign(Object.assign({}, spec), { label: `\"${spec.label}\"` });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n    let allAttrs = [], globalAttrs = [];\n    let attrValues = Object.create(null);\n    for (let s of attrSpecs) {\n        let completion = attrCompletion(s);\n        allAttrs.push(completion);\n        if (s.global)\n            globalAttrs.push(completion);\n        if (s.values)\n            attrValues[s.name] = s.values.map(valueCompletion);\n    }\n    let allElements = [], topElements = [];\n    let byName = Object.create(null);\n    for (let s of eltSpecs) {\n        let attrs = globalAttrs, attrVals = attrValues;\n        if (s.attributes)\n            attrs = attrs.concat(s.attributes.map(s => {\n                if (typeof s == \"string\")\n                    return allAttrs.find(a => a.label == s) || { label: s, type: \"property\" };\n                if (s.values) {\n                    if (attrVals == attrValues)\n                        attrVals = Object.create(attrVals);\n                    attrVals[s.name] = s.values.map(valueCompletion);\n                }\n                return attrCompletion(s);\n            }));\n        let elt = new Element(s, attrs, attrVals);\n        byName[elt.name] = elt;\n        allElements.push(elt);\n        if (s.top)\n            topElements.push(elt);\n    }\n    if (!topElements.length)\n        topElements = allElements;\n    for (let i = 0; i < allElements.length; i++) {\n        let s = eltSpecs[i], elt = allElements[i];\n        if (s.children) {\n            for (let ch of s.children)\n                if (byName[ch])\n                    elt.children.push(byName[ch]);\n        }\n        else {\n            elt.children = allElements;\n        }\n    }\n    return cx => {\n        var _a;\n        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);\n        if (!loc || (loc.type == \"tag\" && !cx.explicit))\n            return null;\n        let { type, from, context } = loc;\n        if (type == \"openTag\") {\n            let children = topElements;\n            let parentName = elementName(doc, context);\n            if (parentName) {\n                let parent = byName[parentName];\n                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n            }\n            return {\n                from,\n                options: children.map(ch => ch.completion),\n                validFor: Identifier\n            };\n        }\n        else if (type == \"closeTag\") {\n            let parentName = elementName(doc, context);\n            return parentName ? {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + \">\", type: \"type\" }],\n                validFor: Identifier\n            } : null;\n        }\n        else if (type == \"attrName\") {\n            let parent = byName[tagName(doc, context)];\n            return {\n                from,\n                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n                validFor: Identifier\n            };\n        }\n        else if (type == \"attrValue\") {\n            let attr = attrName(doc, context, from);\n            if (!attr)\n                return null;\n            let parent = byName[tagName(doc, context)];\n            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n            if (!values || !values.length)\n                return null;\n            return {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n                options: values,\n                validFor: /^\"[^\"]*\"?$/\n            };\n        }\n        else if (type == \"tag\") {\n            let parentName = elementName(doc, context), parent = byName[parentName];\n            let closing = [], last = context && context.lastChild;\n            if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName))\n                closing.push(parent ? parent.closeCompletion : { label: \"</\" + parentName + \">\", type: \"type\", boost: 2 });\n            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n                let openTag = context.firstChild;\n                if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))\n                    options = options.concat(parent.text);\n            }\n            return {\n                from,\n                options,\n                validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n            };\n        }\n        else {\n            return null;\n        }\n    };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"xml\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(subtree) {\n                    let first = subtree.firstChild, last = subtree.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : subtree.to };\n                }\n            }),\n            /*@__PURE__*/bracketMatchingHandle.add({\n                \"OpenTag CloseTag\": node => node.getChild(\"TagName\")\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/$/\n    }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml(conf = {}) {\n    return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n    }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}